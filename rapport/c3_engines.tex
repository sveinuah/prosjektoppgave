%===================================== CHAP 3 =================================

\chapter{Simulator platform}

There are two main approaches to making the simulator. One is implementing the camera model in existing simulators. Another is to create the simulator in a game engine. Both approaches provide a platform and tools to design a world to simulate in and an interface to control this world, and the objects within. The main differences come from the way physics is implemented. As a rule of thumb, game engines need to be more general in their implementation, as video games often need to implement otherworldly or made up physics. This means that the world physics engine needs to be implemented, to provide the same ground framework as a real world physics simulator. 

One advantage game engines have over other simulator platforms is their focus on realistic graphics. The current popularity of the gaming industry, pushes games towards more and more realistic worlds, with more and more realistic sceneries. This pairs well with the current increase development within the fields of visual odometry and SLAM, where realistic imaging and good lighting effects are the most important aspect.

Due to a lack of experience with simulators and game engines, there will only be a focus on open software, with a sizeable community, and that are still used and supported by the developers. Three platforms that matches these criteria are Gazebo \cite{Gazeboweb, GazeboPaper}, Unity \cite{Unityweb} and Unreal Engine \cite{Unrealweb}. For this reason, these platforms will be compared as alternatives. An important note is that this comparison should not be treated as comprehensive comparison of the different simulators or game engines mentioned, and far from all features will be mentioned in this chapter. This comparison is just a result of the initial research done, in order to choose a platform for the project.

\section{Gazebo}

Gazebo is a simulator platform made for robot simulation, with 3D graphics for Linux platforms. It comes with support for four different physics engines \cite{Gazebo_phys}. The four engines are optimized for different purposes, making Gazebo quite versatile when it comes to simulations. Gazebo is fully usable as a standalone, but it also comes with native ROS support. This means that you can model your hardware in Gazebo and run the same ROS code with this model, as you would with the physical robot.

The simulations in Gazebo are built from XML-files describing the world, models that inhabit the world, and the physical properties of each model. The models can be attached to one another through joints and links to create more complex models. Gazebo also provides the ability to add specific behaviour to the simulation through plugins. Plugins are compiled C++ code attached to a specific component, like a model, sensor or world. It is also through these plugins you define ROS behaviour.

The camera sensor implements a perspective camera, giving you access to the typical camera parameters: horizontal FOV, image height, image width, color coding, and near and far clipping plane. Gazebo also comes with support for adding Gaussian noise and distorition to the camera. The distortion is based on Brown's distortion model\todo{cite or add to theory}, which models both radial and tangential distortion effects to the outputed picture. There are no shutter speed settings, meaning that motion blur is not naturally supported.

Another drawback of Gazebo is its graphical capabilities. Even though it uses the OGRE rendering engine, and offers the possibility to write plugins spesifically towards the renderer, there are no tools for creating special weather effects like fog, rain, direct sunlight or similar effects that are important problems of computer vision tasks. There are also limited possibilities when it comes to visualizing effects like reflection, transparity and light coming through transparent objects.

\section{Unity and Unreal Engine 4}

Unity and Unreal engine are the most popular game engines freely available. Being game engines, both heavily focus on productivity in graphics design, as well as visuals of the final product. This means that a large part of the software toolkit is based around editing the scene and objects in it to look good. Both engines provide extensive tools for making custom meshes, textures, animations and lighting effects, making the graphical development of the simulation much easier than in Gazebo. In addition to this both Unity and Unreal Engine provide a large library of premade scenes to use freely.

Unity is based around the scripting language C\# to change the behaviour of the object. The script itself is then attached to a spesific object, just like textures. The behaviour is defined through five user defined functions: $Awake()$, $Start()$, $Update()$, $FixedUpdate()$, and $LateUpdate()$. The $Awake()$ and $Start()$ functions are called once, while the rest are called every frame. Most importantly we note that $FixedUpdate()$ is specifically used for updating physics, while $Update()$ is for general purpose updates. However, it is not required to use the provided physics engine.

Unreal Engine is built quite similarly to Unity in regards to how the building blocks of the Editor. However, there are two ways to define behaviour. One is through C++ and the other is through a visual scripting language called Blueprints. The functionality of Blueprints are almost identical to that of the C\# scripting in Unity, however the programming interface is graphical and node based, as seen in Figure~\todo{find ref}. Unreal Engine is completely open source, and you are allowed to make changes to the core engine itself. Through registering as a Epic Games developer, you get access to all features of Unreal Engine through the C++ source code. This enables the ability to apply extra optimizations for your specific problem, and may be relevant for performance critical tasks. The same interface available to the blueprints are also available to C++, giving you the ability to do scripting similar to that of Unity.

Both Unreal Engine and Unity comes with a physics engine, and usage of this engine is completely optional. This is very different from the implementation in Gazebo, where physical properties like mass, inertia are core parts of a model. While the engines do implement solvers for collision, interraction through joint and links and physical properties, there are no initial support for simulation of wind or other fluid mechanics.

When it comes to computer vision applications, there are no native support for this in the engines. This may be solved by using OpenCV \cite{OpenCVweb} as a part of the project. There exists a wrapper for OpenCV in Unity, and you may link the OpenCV libraries directly into your Unreal Engine projects through C++ code. OpenCV provides many computer vision algorithms as well as algorithms for machine learing, and can be used to augment the engine's cameras for wide angle functionality, lens distortions or similar effects. To get an interface to create image datasets from Unreal Engine, a plugin has been created called UnrealCV~\cite{UnrealCV}. This plugin does not support omnidirectional captures or lens models at the moment.

For Unreal Engine 4, there have been been developed a couple of Vehicle simulation plugins. Two promising plugins are Sim4CV \cite{Sim4CV_paper} and AirSim \cite{Airsim_paper, AirsimGit}. Both simulators implement model for an quadcopter and a car, in addition to this they both provide interfaces to place an arbritary amount of camera sensor to vehicles, and a C++ and Python API to the plugin. Sim4CV also provides a MATLAB API, which might be useful as MATLAB has lots of CV toolboxes avalable. 

The differences between the two come in the form of their main focus. Sim4CV focus on computer vision, and the usage of computer vision for machine learning and deep learning, while AirSim mainly focuses on supporting different types of sensors. This means that for projects aiming for sensor fusion, or testing complete vehicle systems, AirSim would be preferred. Sim4CV may on the other hand be preferrable for AI computer vision projects. Especially for deep learning, as it implements a TensorFlow-like interface.

\section{Choosing a platform for the simulator}

As mentioned in Section~\ref{sec:introduction}, the goal of this project is to implement a simulator for capturing realistic 360 degree images with fisheye lenses, with the ability to calibrate the camera parameters to match real fisheye lens cameras and solutions to capture 360 degree footage. In addition, the simulator should provide an interface to ROS~\cite{ROSpaper}, to enable the simulator to be used with already existing implementations of SLAM and Visual odometry algorithms for ROS. This criteria limits the usage to Linux based systems, as ROS are currently only available on Linux platforms. While Unity and Unreal Engine are most optimized for development on Windows or Mac OS, both provide the ability to build their latest releases on Linux. Table~\ref{tab:platform_comparison} shows a comparison between Gazebo, Unity and Unreal Engine, with some elements central to the project.

\begin{table}[!htb]
    \centering
    \begin{tabular}{|c|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2.5cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|} \hline
        \textbf{Engine}          & \textbf{Language}  & \textbf{ROS support} & \textbf{360 degree camera}   & \textbf{Sensor support} & \textbf{Platform}              \\ \hline \hline
        Gazebo          & C++, XML           & Yes           & No  & Yes & Linux                 \\ \hline
        Unity           & C\#                    & No            & Yes & Plugins & Windows, Mac OS, Linux \\ \hline
        Unreal Engine   & C++, Blueprint        & No            & Yes & Plugins & Windows, Mac OS, Linux \\ \hline
    \end{tabular}
    \caption{Comparison table between Gazebo, Unity and Unreal Engine}
    \label{tab:platform_comparison}
\end{table}

The main advantages Gazebo has over the game engines is its implementation of physics engine implementation, its ROS integration and its modular sensor setup. A larger part of the community is also familiar, and uses Gazebo for CV-purposes, which may provide more useful help online for the project. The main drawback of Gazebo is that there is little to no tooling for graphical development in Gazebo. This means that there are relatively few high quality graphic worlds that are made for Gazebo. Making these from scratch would require much more time and experience, as well as additional graphical software, which is unreasonable for the scope of this project. 

The tools available in the Unreal Engine and Unity, provide a much easier way to make high quality scenes for our camera, or editing scenes that are readily available. The fact that both of these engines also support omnidirectional video capture through cube maps, is also quite helpful, and used directly or as a reference when implementing the 360 camera feature. 

Unreal Engine has some advantages over Unity. The fact that you may write C++ code directly, increases the ability to use libraries like OpenCV without needing additional wrappers. It also simplifies the process of making a ROS interface, as the ROS projects are also compiled from C++ code. Although AirSim started supporting Unity in late autumn 2018, it was only available for Unreal Engine 4 at the start of this project. As I did not find any equivalent plugins for Unity, Unreal Engine was chosen as the simulator platform. AirSim was also chosen over Sim4CV because of the availability of the source code on Github, making it easy to see that the project was still developed and had a sizeable user base. The versatility it provides for additional sensors is also something that may be utilized in future projects.

\cleardoublepage